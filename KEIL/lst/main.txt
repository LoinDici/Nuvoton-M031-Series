; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\rk3399_i2c_SPI_Flash -I.\RTE\_rk3399_i2c_SPI_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.3.10\Device\M031\Include -D__MICROLIB -D__UVISION_VERSION=532 -D_RTE_ -D_RTE_ -DxxDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;7      
;;;8      void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1d              LDR      r4,|L1.124|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L1.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L1.10|
;;;9      {    
;;;10     		/*---------------------------------------------------------------------------------------------------------*/
;;;11         /* Init System Clock                                                                                       */
;;;12         /*---------------------------------------------------------------------------------------------------------*/
;;;13     
;;;14         /* Unlock protected registers */
;;;15         SYS_UnlockReg();
;;;16     
;;;17         /* Enable HIRC clock */
;;;18         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;19     
;;;20         /* Waiting for HIRC clock ready */
;;;21         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;22     
;;;23         /* Switch HCLK clock source to HIRC and HCLK source divide 1 */
;;;24         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;25     	
;;;26         /* Enable module clock */
;;;27         CLK_EnableModuleClock(UART0_MODULE);
00002a  4d15              LDR      r5,|L1.128|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;28         CLK_EnableModuleClock(SPI0_MODULE);
000032  4e14              LDR      r6,|L1.132|
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;29     	
;;;30         /* Set module clock */
;;;31         CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_PCLK1, MODULE_NoMsk);
00003a  2200              MOVS     r2,#0
00003c  2120              MOVS     r1,#0x20
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       CLK_SetModuleClock
;;;32         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000044  2103              MOVS     r1,#3
000046  2200              MOVS     r2,#0
000048  0609              LSLS     r1,r1,#24
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       CLK_SetModuleClock
;;;33     
;;;34         /* Enable I2C0 clock */
;;;35         CLK_EnableModuleClock(I2C0_MODULE);
000050  480a              LDR      r0,|L1.124|
000052  38f8              SUBS     r0,r0,#0xf8
000054  f7fffffe          BL       CLK_EnableModuleClock
;;;36     
;;;37         /* Update System Core Clock */
;;;38         /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and CyclesPerUs automatically. */
;;;39         SystemCoreClockUpdate();
000058  f7fffffe          BL       SystemCoreClockUpdate
;;;40     
;;;41         /*---------------------------------------------------------------------------------------------------------*/
;;;42         /* Init I/O Multi-function                                                                                 */
;;;43         /*---------------------------------------------------------------------------------------------------------*/
;;;44         /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;45         SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |
00005c  06a8              LSLS     r0,r5,#26
00005e  6bc2              LDR      r2,[r0,#0x3c]
000060  21ff              MOVS     r1,#0xff
000062  0409              LSLS     r1,r1,#16
000064  2333              MOVS     r3,#0x33
000066  438a              BICS     r2,r2,r1
000068  045b              LSLS     r3,r3,#17
00006a  18d2              ADDS     r2,r2,r3
00006c  63c2              STR      r2,[r0,#0x3c]
;;;46                         (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;47     
;;;48         /* Set I2C0 multi-function pins */
;;;49         SYS->GPB_MFPL = (SYS->GPB_MFPL & ~(SYS_GPB_MFPL_PB4MFP_Msk | SYS_GPB_MFPL_PB5MFP_Msk)) |
00006e  6b82              LDR      r2,[r0,#0x38]
000070  438a              BICS     r2,r2,r1
000072  18d1              ADDS     r1,r2,r3
000074  6381              STR      r1,[r0,#0x38]
000076  2000              MOVS     r0,#0
000078  6020              STR      r0,[r4,#0]
;;;50                         (SYS_GPB_MFPL_PB4MFP_I2C0_SDA | SYS_GPB_MFPL_PB5MFP_I2C0_SCL);
;;;51     
;;;52         /* Lock protected registers */
;;;53         SYS_LockReg();
;;;54     }
00007a  bd70              POP      {r4-r6,pc}
;;;55     
                          ENDP

                  |L1.124|
                          DCD      0x40000100
                  |L1.128|
                          DCD      0x5f803d10
                  |L1.132|
                          DCD      0x6640000d

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;55     
;;;56     void UART0_Init()
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58         /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;59         SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000002  2001              MOVS     r0,#1
000004  0780              LSLS     r0,r0,#30
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  22ff              MOVS     r2,#0xff
00000a  0412              LSLS     r2,r2,#16
00000c  4391              BICS     r1,r1,r2
00000e  63c1              STR      r1,[r0,#0x3c]
;;;60         SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000010  6bc1              LDR      r1,[r0,#0x3c]
000012  2233              MOVS     r2,#0x33
000014  0452              LSLS     r2,r2,#17
000016  4311              ORRS     r1,r1,r2
000018  63c1              STR      r1,[r0,#0x3c]
;;;61     	
;;;62         /* Configure UART0 and set UART0 baud rate */
;;;63         UART_Open(UART0, 115200);
00001a  21e1              MOVS     r1,#0xe1
00001c  0249              LSLS     r1,r1,#9
00001e  4802              LDR      r0,|L2.40|
000020  f7fffffe          BL       UART_Open
;;;64     }
000024  bd10              POP      {r4,pc}
;;;65     
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40070000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;65     
;;;66     int main(void)
000000  f7fffffe          BL       SYS_Init
;;;67     {
;;;68     	uint16_t u16ID;
;;;69     //	SPI_INFO w25q64;
;;;70     
;;;71     	/* Init System, IP clock and multi-function I/O. */
;;;72     	SYS_Init();
;;;73     
;;;74     	/* Init UART0 for printf */
;;;75     	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;76     	
;;;77     	/* Init SPI0 */
;;;78     	SPI0_Init();
000008  f7fffffe          BL       SPI0_Init
;;;79     
;;;80     	/* Set PB.2 and PB.3 as Output mode */
;;;81     	GPIO_SetMode(PB, (BIT2 | BIT3), GPIO_MODE_OUTPUT); 
00000c  2201              MOVS     r2,#1
00000e  210c              MOVS     r1,#0xc
000010  4812              LDR      r0,|L3.92|
000012  f7fffffe          BL       GPIO_SetMode
;;;82     		
;;;83     	/* Set WP# and HOLD# of SPI Flash to high */ 
;;;84     	PB2 = 1;
000016  4812              LDR      r0,|L3.96|
000018  2101              MOVS     r1,#1
00001a  6081              STR      r1,[r0,#8]
;;;85     	PB3 = 1;
00001c  60c1              STR      r1,[r0,#0xc]
;;;86     	
;;;87       /* Init I2C0 */
;;;88       I2C0_Init();
00001e  f7fffffe          BL       I2C0_Init
;;;89     
;;;90       /* I2C enter no address SLV mode */
;;;91       I2C_SET_CONTROL_REG(I2C0, I2C_CTL_SI_AA);
000022  4910              LDR      r1,|L3.100|
000024  6808              LDR      r0,[r1,#0]
000026  223c              MOVS     r2,#0x3c
000028  4390              BICS     r0,r0,r2
00002a  300c              ADDS     r0,r0,#0xc
00002c  6008              STR      r0,[r1,#0]
;;;92     	
;;;93     	/* Check ID of SPI Flash */
;;;94     	if((u16ID = SpiFlash_ReadMidDid()) != SPI_FALSH_ID) {
00002e  f7fffffe          BL       SpiFlash_ReadMidDid
000032  490d              LDR      r1,|L3.104|
000034  4288              CMP      r0,r1
000036  d004              BEQ      |L3.66|
;;;95     		printf("Wrong ID, 0x%x\n", u16ID);
000038  4601              MOV      r1,r0
00003a  a00c              ADR      r0,|L3.108|
00003c  f7fffffe          BL       __2printf
                  |L3.64|
;;;96     		while(1);
000040  e7fe              B        |L3.64|
                  |L3.66|
;;;97     	} else
;;;98     		printf("Flash found: W25Q32 ...\n");
000042  a00e              ADR      r0,|L3.124|
000044  f7fffffe          BL       __2printf
;;;99     	
;;;100    	/* Erase SPI flash */
;;;101      SpiFlash_BlockErase64KB(0);
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SpiFlash_BlockErase64KB
;;;102    
;;;103    	/* Wait ready */
;;;104    	SpiFlash_WaitReady();
00004e  f7fffffe          BL       SpiFlash_WaitReady
;;;105    
;;;106    	printf("[OK]\n");
000052  a011              ADR      r0,|L3.152|
000054  f7fffffe          BL       __2printf
                  |L3.88|
;;;107    
;;;108        while(1)
000058  e7fe              B        |L3.88|
;;;109    			;
;;;110    }
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      0x40004040
                  |L3.96|
                          DCD      0x40004840
                  |L3.100|
                          DCD      0x40080000
                  |L3.104|
                          DCD      0x0000ef16
                  |L3.108|
00006c  57726f6e          DCB      "Wrong ID, 0x%x\n",0
000070  67204944
000074  2c203078
000078  25780a00
                  |L3.124|
00007c  466c6173          DCB      "Flash found: W25Q32 ...\n",0
000080  6820666f
000084  756e643a
000088  20573235
00008c  51333220
000090  2e2e2e0a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L3.152|
000098  5b4f4b5d          DCB      "[OK]\n",0
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_SYS_Init____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_SYS_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_SYS_Init____REVSH|
#line 402
|__asm___6_main_c_SYS_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
